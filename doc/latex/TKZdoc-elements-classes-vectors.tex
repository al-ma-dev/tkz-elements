\newpage

\section{Class \tkzClass{vector}}
\label{sec:class_vector}

A \tkzname{vector} object represents an oriented segment from a tail point $A$ to a head point $B$.
Internally, it is built from two points \tkzVar{za} and \tkzVar{zb}, interpreted as complex numbers.
The vector stores both its geometric endpoints and its analytic data (components, length, direction).



The variable \tkzVar{vector}{V} holds a table used to store vectors. It is optional, and you are free to choose the variable name. However, using \code{V} is a recommended convention for clarity and consistency. If you use a custom variable (e.g., Vectors), you must initialize it manually. The \code{init\_elements()} function reinitializes the \code{V} table if used.

\vspace{1em}
In fact, they are more a class of oriented segments than vectors in the strict mathematical sense.

A vector is defined by giving two points (i.e. two affixes).
|V.AB = vector(z.A, z.B)| creates the vector $(\overrightarrow{AB})$, i.e. the oriented segment with origin $A$ representing a vector. A few rudimentary operations are defined, such as sum, subtraction and multiplication by a scalar.


\subsection{Creating a vector}
\label{sub:creating_a_vector}

The \tkzClass{vector} class represents a vector between two points or a free vector with given coordinates.

\medskip
The result is usually stored in \tkzVar{vector}{V}.

\medskip
\textbf{Short form: }
\begin{mybox}
\begin{verbatim}
V.v1 = vector:new(z.A, z.B) -- from A to B
The short form is equivalent:
V.v1 = vector(z.A, z.B)
\end{verbatim}
\end{mybox}



\subsection{Attributes of a vector}

\vspace{1em}

  \bgroup
  \small
  \catcode`_=12
  \captionof{table}{Vector attributes.}\label{vector:attributes}
  \begin{tabular}{ll}
  \toprule
  \textbf{Attributes}      & \textbf{Reference}\\
  \midrule
  \tkzAttr{vector}{tail}     &  \\
  \tkzAttr{vector}{head}     &  [\ref{ssub:attributes_vector_head}] \\
  \tkzAttr{vector}{type}     &  [\ref{ssub:attributes_vector_type}] \\
  \tkzAttr{vector}{slope}    &  [\ref{ssub:attributes_vector_slope}] \\
  \tkzAttr{vector}{z}        &  [\ref{ssub:attributes_vector_z}] \\
  \tkzAttr{vector}{dx}       &  [\ref{ssub:attributes_vector_d}] \\
  \tkzAttr{vector}{dy}       &  [\ref{ssub:attributes_vector_d}]\\
  \tkzAttr{vector}{norm}     &  [\ref{ssub:attributes_vector_norm}]\\
  \tkzAttr{vector}{mtx}      &  [\ref{ssub:attributes_vector_mtx}] \\
  \bottomrule
  \end{tabular}
  \egroup


\subsubsection{Attribute \tkzAttr{vector}{head}}
\label{ssub:attributes_vector_head}

\begin{minipage}{.5\textwidth}
\directlua{
 init_elements()
 z.O = point(0, 0)
 z.A = point(0, 1)
 z.B = point(3, 4)
 z.C = point(1, 2)
 z.D = point(2, 1)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 V.w = V.u + V.v
 z.E = V.w.head}
\begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,O,E)
  \tkzDrawSegments[->,red](A,B)
  \tkzDrawSegments[->,cyan](A,E)
  \tkzDrawSegments[->,blue](C,D B,E)
  \tkzLabelSegment(A,B){$\overrightarrow{u}$}
  \tkzLabelSegment(C,D){$\overrightarrow{v}$}
  \tkzLabelSegment(A,E){$\overrightarrow{w}$}
\end{tikzpicture}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{tkzexample}[code only]
\directlua{
 init_elements()
 z.O = point(0, 0)
 z.A = point(0, 1)
 z.B = point(3, 4)
 z.C = point(1, 2)
 z.D = point(2, 1)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 V.w = V.u + V.v
 z.E = V.w.head}
\end{tkzexample}
\end{minipage}


\subsubsection{Attributes \tkzAttr{vector}{type}}
\label{ssub:attributes_vector_type}
With previous data:

\begin{mybox}
\code{|V.u.type = 'vector'|}
\end{mybox}

\subsubsection{Attribute \tkzAttr{vector}{slope}}
\label{ssub:attributes_vector_slope}
The attribute gives the slope of the line supporting a vector representative.

\begin{tkzexample}[latex = .5\textwidth]
\directlua{
   z.A = point(-1, 0)
   z.B = point (3, 3)
   V.u = vector(z.A, z.B)
   local d = math.deg(V.u.slope)
   tex.print(utils.format_number(d,3))}
\end{tkzexample}

\subsubsection{Attributes \tkzAttr{vector}{dx}, \tkzAttr{vector}{dy}}
\label{ssub:attributes_vector_d}

These attributes give the coordinates of the vectors in the reference base.

\begin{tkzexample}[latex=.5\textwidth]
\directlua{
  z.A = point(0, 1)
  z.B = point(3, 4)
  z.C = point(3, 2)
  z.D = point(4, 1)
  V.u = vector(z.A, z.B)
  V.v = vector(z.C, z.D)
  V.w = V.u + V.v
  z.E = V.w.head
  local pc = string.char(37)
  local format = "("..pc.."g,"..pc.."g)"
  tex.print("(dx,dy) =
     ",string.format(format, V.w.dx, V.w.dy))
  }
\begin{center}
  \begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,E)
  \tkzDrawSegments[->,red](A,B C,D)
  \tkzDrawSegments[->,blue](A,E B,E)
  \tkzDrawPoints(A,C)
\end{tikzpicture}
  \end{center}
\end{tkzexample}


\subsubsection{Attribute \tkzAttr{vector}{norm}}
\label{ssub:attributes_vector_norm}
This attribute gives the length of the segment between the two ends.

\begin{tkzexample}[latex = .5\textwidth]
\directlua{
   z.A = point(-1, 0)
   z.B = point(3, 3)
   V.u = vector(z.A, z.B)
   V.d = V.u.norm
   tex.print("norm = ",V.d)}
\end{tkzexample}

\subsubsection{Attribute \tkzAttr{vector}{mtx}}
\label{ssub:attributes_vector_mtx}
This involves associating a matrix in the form of a \code{column vector} with the vector under consideration.

\begin{tkzexample}[latex = .5\textwidth]
\directlua{
   z.O = point(1, 0)
   z.I = point(2, 1)
   V.u = vector(z.O, z.I)
   V.u.mtx:print()
   V.v = V.u.mtx:transpose()
   V.v:print()}
\end{tkzexample}

\subsubsection{Attribute \tkzAttr{vector}{z}}
\label{ssub:attributes_vector_z}
This attribute is very useful for working with the \code{\^{}} and \code{..} metamethods.

\begin{tkzexample}[latex = .5\textwidth]
\directlua{
 z.A = point(1, 1)
 z.B = point(2, -1)
 z.C = point(0, 1)
 z.D = point(3, 2)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 n = V.u.z ^ V.v.z
 m = V.u.z .. V.v.z
 tex.print("determinant(u,v) = "..tostring(n))
 tex.print('\\\\')
 tex.print("dot product(u,v) = "..tostring(m))
}
\end{tkzexample}


\newpage

\subsection{Metamethods overview of the class vector}

\vspace{1em}
\bgroup
  \catcode`_=12
  \small
  \captionof{table}{Methods of the class vector.}\label{vector:metamethods}
  \begin{tabular}{ll}
  \toprule
   \textbf{Metamethods} & \textbf{Reference} \\
   \midrule
  \tkzMeta{vector}{add(u,v)}   & [\ref{ssub:method_vector_add}]  \\
  \tkzMeta{vector}{sub(u,v)}   & [\ref{ssub:method_vector_sub}]  \\
  \tkzMeta{vector}{unm(u)} & [\ref{ssub:method_vector_unm}] \\
  \tkzMeta{vector}{mul(k,u)}   & [\ref{ssub:method_vector_mul}]        \\
  \tkzMeta{vector}{pow(k,u)}   & [\ref{ssub:method_vector_det}]        \\
  \tkzMeta{vector}{concat(k,u)}& [\ref{ssub:method_vector_dot}]        \\
  \bottomrule
    \end{tabular}
  \egroup



\subsection{Example of metamethods}

\subsubsection{Method \tkzMeth{vector}{add}}
\label{ssub:method_vector_add}

The sum is defined as follows:

Let V.AB + V.CD result in a vector V.AE defined as follows

If $\overrightarrow{CD} = \overrightarrow{BE} $ then $\overrightarrow{AB} + \overrightarrow{CD} = \overrightarrow{AB} + \overrightarrow{BE} =\overrightarrow{AE}$

\begin{verbatim}
z.A  = point(0, 1)
z.B  = point(3, 4)
z.C  = point(3, 2)
z.D  = point(4, 1)
V.AB = vector(z.A, z.B)
V.CD = vector(z.C, z.D)
V.AE = V.AB + V.CD  % possible V.AB : add (V.CD)
z.E  = V.AE.head % we recover the final point (head)
\end{verbatim}


\begin{tkzexample}[latex=.5\textwidth]
\directlua{
 init_elements()
 z.A = point(0, 1)
 z.B = point(3, 4)
 z.C = point(3, 2)
 z.D = point(4, 1)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 V.w = V.u + V.v % or V.u:add(V.v)
 z.E = V.w.head}
\begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,E)
  \tkzDrawSegments[->,red](A,B)
  \tkzDrawSegments[->,cyan](A,E)
  \tkzDrawSegments[->,blue](C,D B,E)
  \tkzLabelSegment(A,B){$\overrightarrow{u}$}
  \tkzLabelSegment(C,D){$\overrightarrow{v}$}
  \tkzLabelSegment(A,E){$\overrightarrow{w}$}
\end{tikzpicture}
\end{tkzexample}


\subsubsection{Method \tkzMeth{vector}{sub}}
\label{ssub:method_vector_sub}

\begin{tkzexample}[latex=.5\textwidth]
\directlua{
 z.A = point(0, 1)
 z.B = point(3, 4)
 z.C = point(3, 2)
 z.D = point(4, 1)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 V.w = V.u - V.v
 z.E = V.w.head}

\begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,E)
  \tkzDrawSegments[->,red](A,B)
    \tkzDrawSegments[->,cyan](A,E)
   \tkzDrawSegments[->,blue](C,D B,E)
  \tkzLabelSegment(A,B){$\overrightarrow{u}$}
  \tkzLabelSegment(C,D){$\overrightarrow{v}$}
  \tkzLabelSegment(A,E){$\overrightarrow{w}$}
\end{tikzpicture}
\end{tkzexample}


\subsubsection{Method \tkzMeth{vector}{mul}}
\label{ssub:method_vector_mul}
This is, of course, multiplication by a scalar.

\begin{tkzexample}[latex=.5\textwidth]
\directlua{
 init_elements()
 z.A = point(0, 1)
 z.B = point(3, 4)
 z.C = point(3, 2)
 z.D = point(4, 1)
 V.u = vector(z.A, z.B)
 V.v = vector(z.C, z.D)
 V.w = V.u + 2 * V.v
 z.E = V.w.head}

\begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,E)
  \tkzDrawSegments[->,red](A,B)
    \tkzDrawSegments[->,cyan](A,E)
   \tkzDrawSegments[->,blue](C,D B,E)
  \tkzLabelSegment(A,B){$\overrightarrow{u}$}
  \tkzLabelSegment(C,D){$\overrightarrow{v}$}
  \tkzLabelSegment(A,E){$\overrightarrow{w}$}
\end{tikzpicture}
\end{tkzexample}


\subsubsection{Method \tkzMeth{vector}{unm}}
\label{ssub:method_vector_unm}

Cette méthode vous permet d'écrire \code{V.w = -V.v}
\begin{tkzexample}[latex=.5\textwidth]
\directlua{
  z.A = point(0, 1)
  z.B = point(3, 3)
  z.C = point(3, 2)
  z.D = point(4, 1)
  V.u = vector(z.A, z.B)
  V.v = vector(z.C, z.D)
  V.v = -V.v
  V.w = V.u + V.v
  z.E = V.w.head}
\begin{center}
  \begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzLabelPoints(A,B,C,D,E)
  \tkzDrawSegments[->,red](A,B)
  \tkzDrawSegments[->,cyan](A,E)
  \tkzDrawSegments[->,blue](D,C B,E)
\end{tikzpicture}
\end{center}
\end{tkzexample}

\subsubsection{Method \tkzMeth{vector}{\textasciicircum{}}}
\label{ssub:method_vector_det}
Instead of the power, which wouldn't make sense here, we're talking about the determinant of two vectors. Note: the reference frame used is orthonormal and direct.

\begin{mybox}
|V.u = vector(z.A, z.B) with z.A = point(xa, ya) and z.B = point(xb, yb)|
|V.v = vector(z.C, z.D) with z.C = point(xc, yc) and z.D = point(xd, yd)|
then |V.u ^ V.v = xa * yb -  xb * ya|
\end{mybox}

remark : |u ^ v = u.norm * v.norm * sin(u,v)|

\subsubsection{Method \tkzMeth{vector}{..}}
\label{ssub:method_vector_dot}
Instead of the concatenation, which wouldn't make sense here, we're talking about the dot product of two vectors. Note: the reference frame used is orthonormal and direct.

\begin{mybox}
|V.u = vector(z.A, z.B) with z.A = point(xa, ya) and z.B = point(xb, yb)|
|V.v = vector(z.C, z.D) with z.C = point(xc, yc) and z.D = point(xd, yd)|
then |V.u .. V.v = xa * xb +  ya * yb|
\end{mybox}

remark : |V.u .. V.v = V.u.norm * V.v.norm * cos(V.u,V.v)|


We're going to use the two last methods . We can determine the cosine and sine of the angle using the dot product and determinant expressed in the direct orthonormal frame used by the package.

\begin{minipage}{.5\textwidth}
\directlua{
 z.O = point(0, 0)
 z.A = point(5, 0)
 z.B = point(1, -4)
 V.u = vector(z.O, z.A)
 V.v = vector(z.O, z.B)
 local dp = V.u .. V.v % dot product
 local d = V.u ^ V.v % determinant
 % costheta = dp / (u.norm * v.norm)
 % sintheta = d / (u.norm * v.norm)
  an = math.atan(d / dp)}
  \begin{tikzpicture}
  \tkzGetNodes
  \tkzDrawSegments[>=stealth,->](O,A O,B)
  \tkzDrawPoints(O)
  \tkzLabelPoints(A,B)
  \tkzLabelPoints[left](O)
  \tkzMarkAngle[<-,>=stealth](B,O,A)
  \tkzLabelAngle[pos=2](B,O,A){$\directlua{
  local format = string.char(37) .. ".2f"
  tex.print(string.format( format , math.deg(an)))}$ deg}
  \end{tikzpicture}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{tkzexample}[code only]
\directlua{
  z.O = point(0, 0)
  z.A = point(5, 0)
  z.B = point(1, -4)
  V.u = vector(z.O, z.A)
  V.v = vector(z.O, z.B)
  local dp = V.u .. V.v % dot product
  local d = V.u ^ V.v % determinant
  % costheta = dp / (u.norm * v.norm)
  % sintheta = d / (u.norm * v.norm)
  an = math.atan(d / dp)}
\end{tkzexample}
\end{minipage}

The code required to display the angle measurement is as follows:

\begin{tkzexample}[code only]
  \tkzLabelAngle[pos=2](B,O,A){$\directlua{
  local format = string.char(37) .. ".2f"
  tex.print(string.format( format , math.deg(an)))}$ deg}
\end{tkzexample}

% subsubsection method_vector_dot (end)`



\smallskip
  The main methods provided by the \tkzClass{vector} class are summarised below.

\medskip
 \bgroup
 \catcode`_=12
 \small
 \captionof{table}{Methods of the class vector.}\label{vector:methods}
 \begin{tabular}{ll}
 \toprule
   \textbf{Methods} & \textbf{Reference} \\
   \midrule
  \tkzMeth{vector}{new(pt, pt)}    & Note\footnote{vector(pt, pt) (short form, recommended)}; \ref{sub:creating_a_vector}                                        \\
  \tkzMeth{vector}{is\_zero([EPS])} & \\
  \tkzMeth{vector}{is\_parallel(v,[EPS])} & \\
  \tkzMeth{vector}{is\_orthogonal(v,[EPS])} & \\
  \tkzMeth{vector}{get()}   & \\
  \tkzMeth{vector}{add(v)}      & \\
  \tkzMeth{vector}{scale(d)}    & \\
  \tkzMeth{vector}{dot(v)}      &\\
   \tkzMeth{vector}{cross(v)}    &\\
  \tkzMeth{vector}{normalize()}   & [\ref{ssub:method_vector_normalize}]     \\
   \tkzMeth{vector}{angle\_to(v)} & \\
  \tkzMeth{vector}{at (pt)}         & [\ref{ssub:method_vector_at}]            \\
  \tkzMeth{vector}{rotate(\tkzVar{$\theta$})} & \\
  \tkzMeth{vector}{orthogonal([side],[length])} & \\
  \bottomrule
  \end{tabular}
\egroup


\subsection{Example of methods}

\subsubsection{Method \tkzMeth{vector}{normalize()}}
\label{ssub:method_vector_normalize}
This method produces a normalized vector that is collinear with the initial vector.

 \begin{tkzexample}[latex = .5\textwidth]
   \directlua{
   init_elements()
   z.A = point(0, 1)
   z.B = point(3, 4)
   V.AB = vector(z.A, z.B)
   V.AN = V.AB:normalize()
   z.N = V.AN.head}
   \begin{tikzpicture}
   \tkzGetNodes
   \tkzDrawSegments(A,B)
   \tkzDrawPoints(A,B,N)
   \tkzLabelPoints(A,B,N)
   \end{tikzpicture}
 \end{tkzexample}

\subsubsection{Method \tkzMeth{vector}{at()}}
\label{ssub:method_vector_at}

 \begin{tkzexample}[latex = .5\textwidth]
   \directlua{
   init_elements()
   z.A = point(0, 1)
   z.B = point(3, 4)
   z.O = point(0, 0)
   V.AB = vector(z.A, z.B)
   V.OC = V.AB:at(z.O)
   z.C = V.OC.head}
   \begin{tikzpicture}
   \tkzGetNodes
   \tkzDrawSegments(A,B O,C)
   \tkzDrawPoints(A,B,O,C)
   \tkzLabelPoints(A,B,O,C)
   \end{tikzpicture}
 \end{tkzexample}

\subsubsection{Method  \tkzMeth{vector}{orthogonal([side],[length])}}
\label{ssub:method_vector_orthogonal_r}

\begin{verbatim}
Vperp  = V:orthogonal()           -- default: "ccw"
VperpC = V:orthogonal("cw")       -- clockwise orthogonal
Vlen   = V:orthogonal("ccw", 2.0) -- orthogonal of prescribed length
\end{verbatim}

The \tkzMeth{vector}{orthogonal} method constructs an orthogonal vector to \code{V},
with the same tail:
\begin{itemize}
  \item the optional argument \tkzVar{side} may be \code{"ccw"} (counter-clockwise,
        the default) or \code{"cw"} (clockwise),
  \item the optional argument \tkzVar{length} may be used to prescribe the norm
        of the resulting vector; if omitted, the length is determined by a rotation
        of the current vector.
\end{itemize}


\begin{tkzexample}[latex=.5\textwidth]
 \directlua{
 init_elements()
 z.A = point(0, 1)
 z.B = point(3, 4)
 V.AB = vector(z.A, z.B)
 V.AR = V.AB:orthogonal(2 * math.sqrt(2))
 z.R = V.AR.head
 V.AS = V.AB:orthogonal("cw",2)
 z.S = V.AS.head}
\begin{center}
 \begin{tikzpicture}[gridded]
  \tkzGetNodes
  \tkzDrawSegments[>=stealth,->,
    red](A,B A,R A,S)
  \tkzLabelPoints(A,B,R,S)
\end{tikzpicture}
\end{center}
\end{tkzexample}


\subsubsection{Predicates: \tkzMeth{vector}{is\_zero}, \tkzMeth{vector}{is\_parallel}, \tkzMeth{vector}{is\_orthogonal}}

\begin{verbatim}
if V:is_zero() then ... end
if V:is_parallel(W) then ... end
if V:is_orthogonal(W) then ... end
\end{verbatim}

These methods test basic geometric relations between vectors, using an optional
tolerance \tkzVar{EPS}, which defaults to \tkzVar{tkz.epsilon}. They are convenient
when deciding whether two directions should be treated as parallel or orthogonal
in numerical computations.

\endinput